<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome to Depaso - 牛排&火腿&Bistro</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #ff6b35;
            --secondary-color: #f7931e;
            --accent-color: #ffd23f;
            --text-dark: #2c3e50;
            --text-light: #7f8c8d;
            --bg-light: #f8f9fa;
            --white: #ffffff;
            --shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
            --shadow-hover: 0 20px 60px rgba(0, 0, 0, 0.15);
            --gradient-primary: linear-gradient(135deg, #ff6b35, #f7931e);
            --gradient-secondary: linear-gradient(135deg, #ffd23f, #ff6b35);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            line-height: 1.6;
            color: var(--text-dark);
            overflow-x: hidden;
            background: var(--bg-light);
        }

        /* Navigation */
        .navbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            height: 8px;
            overflow: hidden;
        }

        .gradient-strip {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                #ff6b35 0%, 
                #f7931e 25%, 
                #ffd23f 50%, 
                #f7931e 75%, 
                #ff6b35 100%);
            background-size: 200% 100%;
            animation: gradientFlow 3s ease-in-out infinite;
        }

        @keyframes gradientFlow {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }

        /* Hero Section */
        .hero {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            background: linear-gradient(135deg, #ff6b35 0%, #f7931e 50%, #ffd23f 100%);
            overflow: hidden;
        }

        .hero::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="50" cy="50" r="1" fill="white" opacity="0.1"/></pattern></defs><rect width="100" height="100" fill="url(%23grain)"/></svg>');
            opacity: 0.3;
            z-index: 1;
        }

        .light-rays {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 2;
        }

        .light-rays-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .hero-content {
            text-align: center;
            color: white;
            z-index: 3;
            position: relative;
            max-width: 800px;
            padding: 0 2rem;
        }

        .hero-title {
            font-size: clamp(3rem, 8vw, 6rem);
            font-weight: 700;
            margin-bottom: 1rem;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            font-family: "Arial Rounded MT Bold", "Arial Rounded", "Arial", sans-serif;
        }

        .hero-subtitle {
            font-size: clamp(1.2rem, 3vw, 2rem);
            font-weight: 300;
            margin-bottom: 2rem;
            opacity: 0.9;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }

        .hero-description {
            font-size: clamp(1rem, 2vw, 1.2rem);
            margin-bottom: 3rem;
            opacity: 0.8;
            text-align: center;
            position: relative;
            overflow: hidden;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            line-height: 1.6;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            font-family: "新宋体", "NSimSun", "SimSun", serif;
        }

        .hero-description::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 50%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(255, 255, 255, 0.1) 0%, transparent 50%);
            opacity: 0.3;
            pointer-events: none;
            animation: noiseAnimation 0.1s steps(10) infinite;
            mix-blend-mode: overlay;
        }

        .hero-description::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 2px,
                    rgba(255, 255, 255, 0.03) 2px,
                    rgba(255, 255, 255, 0.03) 4px
                ),
                repeating-linear-gradient(
                    90deg,
                    transparent,
                    transparent 2px,
                    rgba(255, 255, 255, 0.03) 2px,
                    rgba(255, 255, 255, 0.03) 4px
                );
            pointer-events: none;
            animation: noiseGrid 0.15s steps(8) infinite;
        }

        @keyframes noiseAnimation {
            0% { transform: translate(0, 0) rotate(0deg); }
            10% { transform: translate(-2px, -1px) rotate(0.5deg); }
            20% { transform: translate(-4px, 2px) rotate(-0.5deg); }
            30% { transform: translate(2px, -3px) rotate(0.3deg); }
            40% { transform: translate(-3px, 4px) rotate(-0.3deg); }
            50% { transform: translate(-5px, 2px) rotate(0.2deg); }
            60% { transform: translate(3px, 0px) rotate(-0.2deg); }
            70% { transform: translate(0px, 3px) rotate(0.1deg); }
            80% { transform: translate(-4px, 2px) rotate(-0.1deg); }
            90% { transform: translate(2px, 1px) rotate(0.05deg); }
            100% { transform: translate(1px, 0px) rotate(0deg); }
        }

        @keyframes noiseGrid {
            0% { transform: translate(0, 0); }
            12.5% { transform: translate(-1px, -1px); }
            25% { transform: translate(-2px, 1px); }
            37.5% { transform: translate(1px, -2px); }
            50% { transform: translate(-1px, 2px); }
            62.5% { transform: translate(2px, -1px); }
            75% { transform: translate(1px, 1px); }
            87.5% { transform: translate(-1px, -1px); }
            100% { transform: translate(0, 0); }
        }

        /* Blur Text Animation Styles */
        .blur-text-word {
            display: inline-block;
            will-change: transform, filter, opacity;
            margin-right: 0.25em;
            text-align: center;
            font-family: "新宋体", "NSimSun", "SimSun", serif;
        }

        .blur-text-char {
            display: inline-block;
            will-change: transform, filter, opacity;
            text-align: center;
            font-family: "新宋体", "NSimSun", "SimSun", serif;
        }

        /* Arial Rounded for English title */
        .hero-title .blur-text-word,
        .hero-title .blur-text-char {
            font-family: "Arial Rounded MT Bold", "Arial Rounded", "Arial", sans-serif;
        }


        .cta-buttons {
            display: flex;
            gap: 1.5rem;
            justify-content: center;
            flex-wrap: wrap;
            animation: fadeInUp 1s ease-out 0.6s both;
            max-width: 600px;
            margin: 0 auto;
        }

        .btn {
            padding: 1rem 2rem;
            border: none;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: 600;
            text-decoration: none;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .btn-primary {
            background: var(--primary-color);
            color: white;
            border: 2px solid white;
            box-shadow: var(--shadow);
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-hover);
            background: #e55a2b;
        }

        .btn-secondary {
            background: white;
            color: var(--primary-color);
            border: 2px solid white;
            box-shadow: var(--shadow);
        }

        .btn-secondary:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-hover);
            background: #f8f9fa;
        }

        .btn-tertiary {
            background: transparent;
            color: white;
            border: 2px solid white;
        }

        .btn-tertiary:hover {
            background: white;
            color: var(--primary-color);
            transform: translateY(-3px);
        }

        /* Floating Elements */
        .floating-elements {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 1;
        }

        .floating-element {
            position: absolute;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            animation: float 6s ease-in-out infinite;
        }

        .floating-element:nth-child(1) {
            width: 80px;
            height: 80px;
            top: 20%;
            left: 10%;
            animation-delay: 0s;
        }

        .floating-element:nth-child(2) {
            width: 120px;
            height: 120px;
            top: 60%;
            right: 15%;
            animation-delay: 2s;
        }

        .floating-element:nth-child(3) {
            width: 60px;
            height: 60px;
            bottom: 30%;
            left: 20%;
            animation-delay: 4s;
        }



        /* Animations */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-20px);
            }
        }

        /* Mobile Menu */
        .mobile-menu-toggle {
            display: none;
        }

        /* Responsive Design */
        @media (max-width: 768px) {

            .hero {
                padding: 2rem 0;
            }

            .cta-buttons {
                flex-direction: column;
                align-items: center;
                gap: 1rem;
            }

            .btn {
                width: 100%;
                max-width: 280px;
                padding: 0.9rem 1.5rem;
            }


        }

        @media (max-width: 480px) {
            .nav-container {
                padding: 1rem;
            }

            .container {
                padding: 0 1rem;
            }

            .hero-content {
                padding: 0 1rem;
            }

            .features {
                padding: 4rem 0;
            }

            .feature-card {
                padding: 1.5rem 1rem;
            }
        }

        /* Smooth scrolling */
        html {
            scroll-behavior: smooth;
        }

        /* Loading animation */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--gradient-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }

        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
    </div>

    <!-- Navigation -->
    <nav class="navbar">
        <div class="gradient-strip"></div>
    </nav>

    <!-- Hero Section -->
    <section class="hero" id="home">
        <div class="floating-elements">
            <div class="floating-element"></div>
            <div class="floating-element"></div>
            <div class="floating-element"></div>
        </div>
        
        <div class="light-rays">
            <canvas class="light-rays-canvas" id="lightRaysCanvas"></canvas>
        </div>
        
        <div class="hero-content">
            <h1 class="hero-title" id="heroTitle">Welcome to Depaso</h1>
            <h2 class="hero-subtitle" id="heroSubtitle">牛排 & 火腿 & Bistro</h2>
            <p class="hero-description" id="heroDescription">
                温馨的社区小馆，用对待家人的心意来对待每一位客人。<br>
                装修环保，食材安心健康，味道纯粹美好。
            </p>
            <div class="cta-buttons">
                <a href="Menu_Main.html" class="btn btn-primary">浏览菜单</a>
                <a href="#contact" class="btn btn-secondary">立即预定</a>
                <a href="#philosophy" class="btn btn-tertiary">我们的理念</a>
            </div>
        </div>
    </section>



    <script>
        // Blur Text Animation Class (inspired by ReactBits)
        class BlurText {
            constructor(element, options = {}) {
                this.element = element;
                this.options = {
                    delay: options.delay || 200,
                    animateBy: options.animateBy || 'words',
                    direction: options.direction || 'top',
                    threshold: options.threshold || 0.1,
                    rootMargin: options.rootMargin || '0px',
                    stepDuration: options.stepDuration || 0.35,
                    ...options
                };
                
                this.inView = false;
                this.init();
            }

            init() {
                this.splitText();
                this.setupIntersectionObserver();
            }

            splitText() {
                const text = this.element.textContent;
                const elements = this.options.animateBy === 'words' ? text.split(' ') : text.split('');
                
                this.element.innerHTML = '';
                
                elements.forEach((segment, index) => {
                    const span = document.createElement('span');
                    span.className = this.options.animateBy === 'words' ? 'blur-text-word' : 'blur-text-char';
                    span.textContent = segment === ' ' ? '\u00A0' : segment;
                    
                    // Add space after words
                    if (this.options.animateBy === 'words' && index < elements.length - 1) {
                        span.textContent += '\u00A0';
                    }
                    
                    // Set initial styles
                    const fromStyles = this.getFromStyles();
                    Object.assign(span.style, fromStyles);
                    
                    this.element.appendChild(span);
                });
            }

            getFromStyles() {
                const direction = this.options.direction;
                return {
                    filter: 'blur(10px)',
                    opacity: '0',
                    transform: `translateY(${direction === 'top' ? '-50px' : '50px'})`,
                    transition: 'all 0.35s ease-out'
                };
            }

            getToStyles() {
                const direction = this.options.direction;
                return [
                    {
                        filter: 'blur(5px)',
                        opacity: '0.5',
                        transform: `translateY(${direction === 'top' ? '5px' : '-5px'})`
                    },
                    {
                        filter: 'blur(0px)',
                        opacity: '1',
                        transform: 'translateY(0px)'
                    }
                ];
            }

            setupIntersectionObserver() {
                const observer = new IntersectionObserver(
                    ([entry]) => {
                        if (entry.isIntersecting) {
                            this.inView = true;
                            this.animate();
                            observer.unobserve(this.element);
                        }
                    },
                    { 
                        threshold: this.options.threshold, 
                        rootMargin: this.options.rootMargin 
                    }
                );
                observer.observe(this.element);
            }

            animate() {
                const spans = this.element.querySelectorAll('span');
                const toStyles = this.getToStyles();
                
                spans.forEach((span, index) => {
                    const delay = (index * this.options.delay) / 1000;
                    
                    setTimeout(() => {
                        // First step
                        setTimeout(() => {
                            Object.assign(span.style, toStyles[0]);
                        }, 0);
                        
                        // Second step
                        setTimeout(() => {
                            Object.assign(span.style, toStyles[1]);
                        }, this.options.stepDuration * 1000);
                        
                    }, delay * 1000);
                });
            }
        }

        // Light Rays Effect Class (ReactBits-inspired)
        class LightRaysEffect {
            constructor(canvas, options = {}) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                this.options = {
                    raysOrigin: options.raysOrigin || 'top-center',
                    raysColor: options.raysColor || '#ffffff',
                    raysSpeed: options.raysSpeed || 1.5,
                    lightSpread: options.lightSpread || 0.8,
                    rayLength: options.rayLength || 1.2,
                    followMouse: options.followMouse !== false,
                    mouseInfluence: options.mouseInfluence || 0.1,
                    noiseAmount: options.noiseAmount || 0.1,
                    distortion: options.distortion || 0.05,
                    ...options
                };
                
                this.mouse = { x: 0.5, y: 0.5 };
                this.smoothMouse = { x: 0.5, y: 0.5 };
                this.animationId = null;
                this.time = 0;
                this.program = null;
                this.uniforms = {};
                
                this.init();
            }

            init() {
                if (!this.gl) {
                    console.warn('WebGL not supported, falling back to canvas 2D');
                    this.initCanvas2D();
                    return;
                }
                
                this.setupWebGL();
                this.setupMouseTracking();
                this.startAnimation();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            setupWebGL() {
                const gl = this.gl;
                
                // Vertex shader
                const vertexShaderSource = `
                    attribute vec2 position;
                    varying vec2 vUv;
                    void main() {
                        vUv = position * 0.5 + 0.5;
                        gl_Position = vec4(position, 0.0, 1.0);
                    }
                `;
                
                // Fragment shader (matching ReactBits implementation)
                const fragmentShaderSource = `
                    precision highp float;
                    
                    uniform float iTime;
                    uniform vec2 iResolution;
                    uniform vec2 rayPos;
                    uniform vec2 rayDir;
                    uniform vec3 raysColor;
                    uniform float raysSpeed;
                    uniform float lightSpread;
                    uniform float rayLength;
                    uniform vec2 mousePos;
                    uniform float mouseInfluence;
                    uniform float noiseAmount;
                    uniform float distortion;
                    
                    varying vec2 vUv;
                    
                    float noise(vec2 st) {
                        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                    }
                    
                    float rayStrength(vec2 raySource, vec2 rayRefDirection, vec2 coord,
                                      float seedA, float seedB, float speed) {
                        vec2 sourceToCoord = coord - raySource;
                        vec2 dirNorm = normalize(sourceToCoord);
                        float cosAngle = dot(dirNorm, rayRefDirection);
                        
                        float distortedAngle = cosAngle + distortion * sin(iTime * 2.0 + length(sourceToCoord) * 0.01) * 0.2;
                        
                        float spreadFactor = pow(max(distortedAngle, 0.0), 1.0 / max(lightSpread, 0.001));
                        
                        float distance = length(sourceToCoord);
                        float maxDistance = iResolution.x * rayLength;
                        float lengthFalloff = clamp((maxDistance - distance) / maxDistance, 0.0, 1.0);
                        
                        float fadeDistance = iResolution.x * 1.0;
                        float fadeFalloff = clamp((fadeDistance - distance) / fadeDistance, 0.5, 1.0);
                        
                        float baseStrength = clamp(
                            (0.45 + 0.15 * sin(distortedAngle * seedA + iTime * speed)) +
                            (0.3 + 0.2 * cos(-distortedAngle * seedB + iTime * speed)),
                            0.0, 1.0
                        );
                        
                        return baseStrength * lengthFalloff * fadeFalloff * spreadFactor;
                    }
                    
                    void main() {
                        vec2 coord = vec2(vUv.x * iResolution.x, (1.0 - vUv.y) * iResolution.y);
                        
                        vec2 finalRayDir = rayDir;
                        if (mouseInfluence > 0.0) {
                            vec2 mouseScreenPos = mousePos * iResolution.xy;
                            vec2 mouseDirection = normalize(mouseScreenPos - rayPos);
                            finalRayDir = normalize(mix(rayDir, mouseDirection, mouseInfluence));
                        }
                        
                        vec4 rays1 = vec4(1.0) * rayStrength(rayPos, finalRayDir, coord, 36.2214, 21.11349, 1.5 * raysSpeed);
                        vec4 rays2 = vec4(1.0) * rayStrength(rayPos, finalRayDir, coord, 22.3991, 18.0234, 1.1 * raysSpeed);
                        
                        vec4 fragColor = rays1 * 0.5 + rays2 * 0.4;
                        
                        if (noiseAmount > 0.0) {
                            float n = noise(coord * 0.01 + iTime * 0.1);
                            fragColor.rgb *= (1.0 - noiseAmount + noiseAmount * n);
                        }
                        
                        float brightness = 1.0 - (coord.y / iResolution.y);
                        fragColor.x *= 0.1 + brightness * 0.8;
                        fragColor.y *= 0.3 + brightness * 0.6;
                        fragColor.z *= 0.5 + brightness * 0.5;
                        
                        fragColor.rgb *= raysColor;
                        
                        gl_FragColor = fragColor;
                    }
                `;
                
                const vertexShader = this.createShader(gl.VERTEX_SHADER, vertexShaderSource);
                const fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
                
                this.program = this.createProgram(vertexShader, fragmentShader);
                
                // Create triangle geometry
                const positions = new Float32Array([
                    -1, -1,
                     1, -1,
                    -1,  1,
                     1,  1
                ]);
                
                this.positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
                
                // Get uniform locations
                this.uniforms = {
                    iTime: gl.getUniformLocation(this.program, 'iTime'),
                    iResolution: gl.getUniformLocation(this.program, 'iResolution'),
                    rayPos: gl.getUniformLocation(this.program, 'rayPos'),
                    rayDir: gl.getUniformLocation(this.program, 'rayDir'),
                    raysColor: gl.getUniformLocation(this.program, 'raysColor'),
                    raysSpeed: gl.getUniformLocation(this.program, 'raysSpeed'),
                    lightSpread: gl.getUniformLocation(this.program, 'lightSpread'),
                    rayLength: gl.getUniformLocation(this.program, 'rayLength'),
                    mousePos: gl.getUniformLocation(this.program, 'mousePos'),
                    mouseInfluence: gl.getUniformLocation(this.program, 'mouseInfluence'),
                    noiseAmount: gl.getUniformLocation(this.program, 'noiseAmount'),
                    distortion: gl.getUniformLocation(this.program, 'distortion')
                };
                
                this.resizeCanvas();
            }

            createShader(type, source) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                
                return shader;
            }

            createProgram(vertexShader, fragmentShader) {
                const gl = this.gl;
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error('Program linking error:', gl.getProgramInfoLog(program));
                    gl.deleteProgram(program);
                    return null;
                }
                
                return program;
            }

            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width * window.devicePixelRatio;
                this.canvas.height = rect.height * window.devicePixelRatio;
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
                
                if (this.gl) {
                    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                }
            }

            setupMouseTracking() {
                if (!this.options.followMouse) return;
                
                const handleMouseMove = (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = (e.clientX - rect.left) / rect.width;
                    this.mouse.y = (e.clientY - rect.top) / rect.height;
                };
                
                window.addEventListener('mousemove', handleMouseMove);
            }

            getAnchorAndDir(origin, w, h) {
                const outside = 0.2;
                switch (origin) {
                    case 'top-left':
                        return { anchor: [0, -outside * h], dir: [0, 1] };
                    case 'top-right':
                        return { anchor: [w, -outside * h], dir: [0, 1] };
                    case 'left':
                        return { anchor: [-outside * w, 0.5 * h], dir: [1, 0] };
                    case 'right':
                        return { anchor: [(1 + outside) * w, 0.5 * h], dir: [-1, 0] };
                    case 'bottom-left':
                        return { anchor: [0, (1 + outside) * h], dir: [0, -1] };
                    case 'bottom-center':
                        return { anchor: [0.5 * w, (1 + outside) * h], dir: [0, -1] };
                    case 'bottom-right':
                        return { anchor: [w, (1 + outside) * h], dir: [0, -1] };
                    default: // "top-center"
                        return { anchor: [0.5 * w, -outside * h], dir: [0, 1] };
                }
            }

            hexToRgb(hex) {
                const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return m ? [parseInt(m[1], 16) / 255, parseInt(m[2], 16) / 255, parseInt(m[3], 16) / 255] : [1, 1, 1];
            }

            render() {
                if (!this.gl || !this.program) return;
                
                const gl = this.gl;
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                // Smooth mouse movement
                const smoothing = 0.92;
                this.smoothMouse.x = this.smoothMouse.x * smoothing + this.mouse.x * (1 - smoothing);
                this.smoothMouse.y = this.smoothMouse.y * smoothing + this.mouse.y * (1 - smoothing);
                
                gl.useProgram(this.program);
                
                // Set uniforms
                gl.uniform1f(this.uniforms.iTime, this.time);
                gl.uniform2f(this.uniforms.iResolution, width, height);
                
                const { anchor, dir } = this.getAnchorAndDir(this.options.raysOrigin, width, height);
                gl.uniform2f(this.uniforms.rayPos, anchor[0], anchor[1]);
                gl.uniform2f(this.uniforms.rayDir, dir[0], dir[1]);
                
                gl.uniform3fv(this.uniforms.raysColor, this.hexToRgb(this.options.raysColor));
                gl.uniform1f(this.uniforms.raysSpeed, this.options.raysSpeed);
                gl.uniform1f(this.uniforms.lightSpread, this.options.lightSpread);
                gl.uniform1f(this.uniforms.rayLength, this.options.rayLength);
                gl.uniform2f(this.uniforms.mousePos, this.smoothMouse.x, this.smoothMouse.y);
                gl.uniform1f(this.uniforms.mouseInfluence, this.options.mouseInfluence);
                gl.uniform1f(this.uniforms.noiseAmount, this.options.noiseAmount);
                gl.uniform1f(this.uniforms.distortion, this.options.distortion);
                
                // Draw
                gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                const positionLocation = gl.getAttribLocation(this.program, 'position');
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
                
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }

            startAnimation() {
                const animate = (timestamp) => {
                    this.time = timestamp * 0.001;
                    this.render();
                    this.animationId = requestAnimationFrame(animate);
                };
                this.animationId = requestAnimationFrame(animate);
            }

            destroy() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                window.removeEventListener('resize', this.resizeCanvas);
            }
        }

        // Noise Animation Class (inspired by ReactBits)
        class NoiseEffect {
            constructor(element) {
                this.element = element;
                this.canvas = null;
                this.ctx = null;
                this.animationId = null;
                this.init();
            }

            init() {
                this.createCanvas();
                this.startAnimation();
            }

            createCanvas() {
                this.canvas = document.createElement('canvas');
                this.canvas.style.position = 'absolute';
                this.canvas.style.top = '0';
                this.canvas.style.left = '0';
                this.canvas.style.width = '100%';
                this.canvas.style.height = '100%';
                this.canvas.style.pointerEvents = 'none';
                this.canvas.style.opacity = '0.1';
                this.canvas.style.mixBlendMode = 'overlay';
                
                this.element.appendChild(this.canvas);
                this.ctx = this.canvas.getContext('2d');
                this.resizeCanvas();
            }

            resizeCanvas() {
                const rect = this.element.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }

            generateNoise() {
                const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    const noise = Math.random() * 255;
                    data[i] = noise;     // Red
                    data[i + 1] = noise; // Green
                    data[i + 2] = noise; // Blue
                    data[i + 3] = 50;    // Alpha
                }
                
                this.ctx.putImageData(imageData, 0, 0);
            }

            startAnimation() {
                const animate = () => {
                    this.generateNoise();
                    this.animationId = requestAnimationFrame(animate);
                };
                animate();
            }

            destroy() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                if (this.canvas && this.canvas.parentNode) {
                    this.canvas.parentNode.removeChild(this.canvas);
                }
            }
        }

        // Loading screen
        window.addEventListener('load', function() {
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
                
                // Initialize blur text animations
                setTimeout(() => {
                    new BlurText(document.getElementById('heroTitle'), {
                        delay: 150,
                        animateBy: 'words',
                        direction: 'top'
                    });
                    
                    setTimeout(() => {
                        new BlurText(document.getElementById('heroSubtitle'), {
                            delay: 100,
                            animateBy: 'words',
                            direction: 'top'
                        });
                    }, 500);
                    
                    setTimeout(() => {
                        new BlurText(document.getElementById('heroDescription'), {
                            delay: 80,
                            animateBy: 'words',
                            direction: 'top'
                        });
                        
                        // Add noise effect to description
                        setTimeout(() => {
                            new NoiseEffect(document.getElementById('heroDescription'));
                        }, 2000);
                        
                        // Initialize light rays effect
                        setTimeout(() => {
                            const canvas = document.getElementById('lightRaysCanvas');
                            if (canvas) {
                                new LightRaysEffect(canvas, {
                                    raysOrigin: 'top-center',
                                    raysColor: '#ffffff',
                                    raysSpeed: 1.5,
                                    lightSpread: 0.8,
                                    rayLength: 1.2,
                                    followMouse: true,
                                    mouseInfluence: 0.1,
                                    noiseAmount: 0.1,
                                    distortion: 0.05
                                });
                            }
                        }, 1000);
                    }, 1000);
                }, 500);
            }, 1000);
        });


        // Smooth scrolling for anchor links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });



        // Parallax effect for floating elements
        window.addEventListener('scroll', function() {
            const scrolled = window.pageYOffset;
            const parallax = document.querySelectorAll('.floating-element');
            
            parallax.forEach((element, index) => {
                const speed = 0.5 + (index * 0.1);
                element.style.transform = `translateY(${scrolled * speed}px)`;
            });
        });

        // Add hover effects to buttons
        document.querySelectorAll('.btn').forEach(btn => {
            btn.addEventListener('mouseenter', function() {
                this.style.transform = 'translateY(-3px) scale(1.02)';
            });
            
            btn.addEventListener('mouseleave', function() {
                this.style.transform = 'translateY(0) scale(1)';
            });
        });

        // Add click ripple effect
        document.querySelectorAll('.btn, .feature-card').forEach(element => {
            element.addEventListener('click', function(e) {
                const ripple = document.createElement('span');
                const rect = this.getBoundingClientRect();
                const size = Math.max(rect.width, rect.height);
                const x = e.clientX - rect.left - size / 2;
                const y = e.clientY - rect.top - size / 2;
                
                ripple.style.width = ripple.style.height = size + 'px';
                ripple.style.left = x + 'px';
                ripple.style.top = y + 'px';
                ripple.style.position = 'absolute';
                ripple.style.borderRadius = '50%';
                ripple.style.background = 'rgba(255, 255, 255, 0.3)';
                ripple.style.transform = 'scale(0)';
                ripple.style.animation = 'ripple 0.6s linear';
                ripple.style.pointerEvents = 'none';
                
                this.style.position = 'relative';
                this.style.overflow = 'hidden';
                this.appendChild(ripple);
                
                setTimeout(() => {
                    ripple.remove();
                }, 600);
            });
        });

        // Add ripple animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes ripple {
                to {
                    transform: scale(4);
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>
